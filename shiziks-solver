-- fuck it i'm posting it raw

local player = game.Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local TextChatService = game:GetService("TextChatService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")
local Controls = require(player.PlayerScripts:WaitForChild("PlayerModule")):GetControls()

local presentsFolder = workspace:WaitForChild("Presents", 10)
local collectPresentsEnabled = false
local PRESENT_OFFSET = Vector3.new(0, 3, 0)

for _, name in pairs({"autosolver_euler", "autosolver_final", "autosolver"}) do
    local old = game:GetService("CoreGui"):FindFirstChild(name) or player.PlayerGui:FindFirstChild(name)
    if old then old:Destroy() end
end

local isAutoSolving, isLegitActive, isWaitingForRound = false, false, false
local currentTab = "rage"
local calculationMode = "euler"
local freezeEnabled, autoGuess, autoFlagEnabled = true, true, false
local flagRange = 25
local actionDelay, startDelayTime = 0.1, 10
local calculateDelay = 0.5 
local calcOnceTriggered = false 
local waitTimeLeft = 0
local neighborCache = {}
local flaggedDebounce = {}
local lastActionTime, lastCalcTime, lastNotifyTime = tick(), 0, 0
local isGuessing, stopCurrentExecution = false, false

local function chatNotify(msg)
    if tick() - lastNotifyTime < 0.5 then return end 
    lastNotifyTime = tick()
    local formattedMsg = "<b>[autosolver]: " .. msg .. "</b>"
    if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
        local channel = TextChatService:FindFirstChild("TextChannels") and TextChatService.TextChannels:FindFirstChild("RBXSystem")
        if channel then channel:DisplaySystemMessage("<font color='#B4B4B4'>" .. formattedMsg .. "</font>") return end
    end
    pcall(function()
        StarterGui:SetCore("ChatMakeSystemMessage", {
            Text = "[autosolver]: " .. msg,
            Color = Color3.fromRGB(180, 180, 180),
            Font = Enum.Font.GothamBold,
            FontSize = Enum.FontSize.Size18
        })
    end)
end

if presentsFolder then
    presentsFolder.ChildAdded:Connect(function(child)
        if not collectPresentsEnabled then return end
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if hrp and child then
            local startTime = tick()
            local connection
            connection = RunService.Heartbeat:Connect(function()
                if tick() - startTime >= 5 or not child or not child.Parent or not hrp or not hrp.Parent or not collectPresentsEnabled then
                    connection:Disconnect()
                    return
                end
                local targetCF = child:GetPivot()
                if targetCF then
                    hrp.CFrame = targetCF + PRESENT_OFFSET
                end
            end)
        end
    end)
end

local function handleDeath()
    if not isAutoSolving and not isLegitActive then return end
    local deathMsg = isGuessing and "didn't guess right." or "accidentally stepped on a mine/reseted."
    chatNotify(deathMsg)
    isGuessing = false
    stopCurrentExecution = true
    neighborCache = {}
end

local function setupChar(char)
    if not char then return end
    stopCurrentExecution = false
    local hum = char:WaitForChild("Humanoid", 10)
    if hum then hum.Died:Connect(handleDeath) end
end

if player.Character then setupChar(player.Character) end
player.CharacterAdded:Connect(setupChar)

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "autosolver_final"
pcall(function() screenGui.Parent = game:GetService("CoreGui") end)
if not screenGui.Parent then screenGui.Parent = player:WaitForChild("PlayerGui") end

local header = Instance.new("Frame", screenGui)
header.Size = UDim2.new(0, 340, 0, 35)
header.Position = UDim2.new(0.5, -170, 0.3, 0)
header.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
header.BorderSizePixel = 0
header.Draggable, header.Active = true, true

local title = Instance.new("TextLabel", header)
title.Size = UDim2.new(1, -70, 1, 0)
title.Position = UDim2.new(0, 15, 0, 0)
title.Text = "autosolver | dc: @deadshizik"
title.TextColor3 = Color3.new(1, 1, 1)
title.Font = Enum.Font.GothamBold
title.TextSize = 13
title.TextXAlignment = Enum.TextXAlignment.Left
title.BackgroundTransparency = 1

local mainBody = Instance.new("Frame", header)
mainBody.Size = UDim2.new(1, 0, 0, 240)
mainBody.Position = UDim2.new(0, 0, 1, 1)
mainBody.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
mainBody.BorderSizePixel = 0

local minimizeBtn = Instance.new("TextButton", header)
minimizeBtn.Size = UDim2.new(0, 25, 0, 25)
minimizeBtn.Position = UDim2.new(1, -30, 0, 5)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
minimizeBtn.BorderSizePixel = 0
minimizeBtn.Text = "-"
minimizeBtn.TextColor3 = Color3.new(1, 1, 1)
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 18
minimizeBtn.ZIndex = 20

local isMinimized = false
minimizeBtn.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    mainBody.Visible = not isMinimized
    minimizeBtn.Text = isMinimized and "+" or "-"
end)

local function refreshStatusUI()
    local text, color
    if isWaitingForRound then
        text = "status: waiting (" .. string.format("%.1f", waitTimeLeft) .. ")"
        color = Color3.fromRGB(200, 100, 0)
    elseif (currentTab == "rage" and isAutoSolving) or (currentTab == "legit" and isLegitActive) then
        text = "status: running"
        color = Color3.fromRGB(50, 150, 50)
    else
        text = "status: off"
        color = Color3.fromRGB(150, 50, 50)
    end
    if _G.statusRage then 
        _G.statusRage.Text = text
        _G.statusRage.BackgroundColor3 = color
        _G.statusRage.TextColor3 = Color3.new(1,1,1) 
    end
    if _G.statusLegit then 
        _G.statusLegit.Text = text
        _G.statusLegit.BackgroundColor3 = color
        _G.statusLegit.TextColor3 = Color3.new(1,1,1) 
    end
end

local function isCellOpen(part)
    if not part or not part.Parent then return true end
    local isBeige = (part.Color.R > 0.7 and part.Color.G > 0.7 and part.Color.B < 0.6)
    return part.Transparency > 0.5 or isBeige or part:FindFirstChild("NumberGui")
end

local function isAlreadyFlagged(part)
    return part:FindFirstChild("Flag") or part:FindFirstChild("BombFlag") or part:FindFirstChild("FlagModel")
end

local function updatePhysics()
    local char = player.Character
    if not char then return end
    local active = (isAutoSolving and not isWaitingForRound and freezeEnabled and currentTab == "rage")
    for _, p in ipairs(char:GetDescendants()) do 
        if p:IsA("BasePart") then p.Anchored = active end 
    end
    if active then Controls:Disable() else Controls:Enable() end
end

local function teleportTo(target)
    if stopCurrentExecution or not target or not target.Parent or isCellOpen(target) then return end
    local char = player.Character
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if not stopCurrentExecution and freezeEnabled and currentTab == "rage" then
        for _, p in ipairs(char:GetDescendants()) do if p:IsA("BasePart") then p.Anchored = false end end
        root.CFrame = target.CFrame * CFrame.new(0, 3.1, 0)
        root.Velocity = Vector3.new(0, -100, 0)
        task.wait(0.01)
        updatePhysics()
    elseif not stopCurrentExecution then
        root.CFrame = target.CFrame * CFrame.new(0, 2.8, 0)
    end
end

local function getSolverData()
    local folder = workspace:FindFirstChild("Flag") and workspace.Flag:FindFirstChild("Parts")
    if not folder then return {} end
    local numberData = {}
    local allParts = folder:GetChildren()
    for _, cell in ipairs(allParts) do
        if not isCellOpen(cell) then continue end
        local label = cell:FindFirstChild("NumberGui") and cell.NumberGui:FindFirstChildOfClass("TextLabel")
        local val = (label and tonumber(label.Text)) or 0 
        if not neighborCache[cell] then
            local nbs = {}
            for _, n in ipairs(allParts) do 
                if n ~= cell and (n.Position - cell.Position).Magnitude < (cell.Size.X * 1.8) then table.insert(nbs, n) end 
            end
            neighborCache[cell] = nbs
        end
        local hidden, mines = {}, 0
        for _, n in ipairs(neighborCache[cell]) do
            if not isCellOpen(n) then
                if n.Color == Color3.new(0,0,0) then mines = mines + 1 else table.insert(hidden, n) end
            end
        end
        if #hidden > 0 or val == 0 then table.insert(numberData, {obj = cell, eVal = val - mines, hidden = hidden}) end
    end
    return numberData
end

function mainLoop()
    if stopCurrentExecution then return end
    if currentTab == "legit" and isLegitActive and not calcOnceTriggered then
        if tick() - lastCalcTime < calculateDelay then return end
    end
    if (not isAutoSolving and not isLegitActive and not calcOnceTriggered) or isWaitingForRound then return end
    lastCalcTime = tick()
    local data = getSolverData()
    local safeQueue, mineQueue, riskyCells = {}, {}, {}
    local foundAnything = false

    for i = 1, #data do
        for j = 1, #data do
            if i ~= j then
                local d1, d2 = data[i], data[j]
                if (d1.obj.Position - d2.obj.Position).Magnitude < 12 then
                    local s1, s2 = d1.hidden, d2.hidden
                    local isSubset = true
                    for _, x in ipairs(s1) do
                        local found = false
                        for _, y in ipairs(s2) do if x == y then found = true; break end end
                        if not found then isSubset = false; break end
                    end
                    if isSubset and #s2 > #s1 then
                        local diffMines = d2.eVal - d1.eVal
                        local diffCells = {}
                        for _, x in ipairs(s2) do
                            local inS1 = false
                            for _, y in ipairs(s1) do if x == y then inS1 = true; break end end
                            if not inS1 then table.insert(diffCells, x) end
                        end
                        if diffMines == 0 then
                            for _, n in ipairs(diffCells) do table.insert(safeQueue, n); foundAnything = true end
                        elseif diffMines == #diffCells then
                            for _, n in ipairs(diffCells) do table.insert(mineQueue, n); foundAnything = true end
                        end
                    end
                end
            end
        end
    end

    local basicSafe, basicMines = {}, {}
    for _, d in ipairs(data) do
        if #d.hidden > 0 then
            if #d.hidden == d.eVal then
                for _, n in ipairs(d.hidden) do table.insert(basicMines, n); foundAnything = true end
            elseif d.eVal <= 0 then
                for _, n in ipairs(d.hidden) do table.insert(basicSafe, n); foundAnything = true end
            end
        end
    end

    if currentTab == "rage" and isAutoSolving then
        for _, m in ipairs(mineQueue) do m.Color = Color3.new(0,0,0) end
        for _, m in ipairs(basicMines) do m.Color = Color3.new(0,0,0) end
        local targetQueue = #safeQueue > 0 and safeQueue or basicSafe
        if #targetQueue > 0 then
            isGuessing = false
            for _, s in ipairs(targetQueue) do 
                if stopCurrentExecution or not isAutoSolving then break end 
                if not isCellOpen(s) then teleportTo(s); task.wait(actionDelay) end
            end
        elseif autoGuess and not foundAnything and tick() - lastActionTime > 0.8 then
            for _, d in ipairs(data) do for _, n in ipairs(d.hidden) do if n.Color ~= Color3.new(0,0,0) then riskyCells[n] = (riskyCells[n] or 0) + 1 end end end
            local best, maxW = nil, -1
            for c, w in pairs(riskyCells) do if w > maxW then maxW = w; best = c end end
            if best then isGuessing = true; teleportTo(best); lastActionTime = tick() end
        end
    elseif (currentTab == "legit" and isLegitActive) or calcOnceTriggered then
        local finalMines = (calculationMode == "euler" and #mineQueue > 0) and mineQueue or basicMines
        local finalSafe = (calculationMode == "euler" and #safeQueue > 0) and safeQueue or basicSafe
        for _, m in ipairs(finalMines) do 
            m.Color = Color3.new(0, 0, 0)
            if autoFlagEnabled then
                local root = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                if root and (m.Position - root.Position).Magnitude <= flagRange and not isAlreadyFlagged(m) then
                    if not flaggedDebounce[m] or tick() - flaggedDebounce[m] > 1 then
                        local cd = m:FindFirstChildOfClass("ClickDetector", true)
                        if cd then fireclickdetector(cd); flaggedDebounce[m] = tick() end
                    end
                end
            end
        end
        for _, s in ipairs(finalSafe) do s.Color = Color3.new(1, 1, 1) end
        calcOnceTriggered = false
    end
end

local sideBar = Instance.new("Frame", mainBody)
sideBar.Size = UDim2.new(0, 80, 1, 0)
sideBar.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
sideBar.BorderSizePixel = 0

local rageTabBtn = Instance.new("TextButton", sideBar)
rageTabBtn.Size = UDim2.new(1, 0, 0, 45)
rageTabBtn.Text = "rage"
rageTabBtn.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
rageTabBtn.TextColor3 = Color3.new(1, 1, 1)
rageTabBtn.Font = Enum.Font.GothamBold
rageTabBtn.BorderSizePixel = 0

local legitTabBtn = Instance.new("TextButton", sideBar)
legitTabBtn.Size = UDim2.new(1, 0, 0, 45)
legitTabBtn.Position = UDim2.new(0, 0, 0, 45)
legitTabBtn.Text = "legit"
legitTabBtn.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
legitTabBtn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
legitTabBtn.Font = Enum.Font.GothamBold
legitTabBtn.BorderSizePixel = 0

local eventTabBtn = Instance.new("TextButton", sideBar)
eventTabBtn.Size = UDim2.new(1, 0, 0, 45)
eventTabBtn.Position = UDim2.new(0, 0, 0, 90)
eventTabBtn.Text = "event"
eventTabBtn.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
eventTabBtn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
eventTabBtn.Font = Enum.Font.GothamBold
eventTabBtn.BorderSizePixel = 0

local rageFrame = Instance.new("Frame", mainBody)
rageFrame.Size = UDim2.new(1, -100, 1, -20)
rageFrame.Position = UDim2.new(0, 90, 0, 10)
rageFrame.BackgroundTransparency = 1

local legitFrame = Instance.new("Frame", mainBody)
legitFrame.Size = UDim2.new(1, -100, 1, -20)
legitFrame.Position = UDim2.new(0, 90, 0, 10)
legitFrame.BackgroundTransparency = 1
legitFrame.Visible = false

local eventFrame = Instance.new("Frame", mainBody)
eventFrame.Size = UDim2.new(1, -100, 1, -20)
eventFrame.Position = UDim2.new(0, 90, 0, 10)
eventFrame.BackgroundTransparency = 1
eventFrame.Visible = false

_G.statusRage = Instance.new("TextButton", rageFrame)
_G.statusRage.Size = UDim2.new(1, 0, 0, 32)
_G.statusRage.Font = Enum.Font.GothamBold
_G.statusRage.BorderSizePixel = 0

_G.statusLegit = Instance.new("TextButton", legitFrame)
_G.statusLegit.Size = UDim2.new(1, 0, 0, 32)
_G.statusLegit.Font = Enum.Font.GothamBold
_G.statusLegit.BorderSizePixel = 0

local function createStrictToggle(parent, text, pos, default, callback)
    local frame = Instance.new("Frame", parent)
    frame.Size = UDim2.new(1, 0, 0, 30)
    frame.Position = pos
    frame.BackgroundTransparency = 1
    local lbl = Instance.new("TextLabel", frame)
    lbl.Size = UDim2.new(0, 120, 1, 0)
    lbl.Text = text:lower()
    lbl.TextColor3 = Color3.fromRGB(180, 180, 180)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 12
    lbl.BackgroundTransparency = 1
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    local bg = Instance.new("Frame", frame)
    bg.Size = UDim2.new(0, 34, 0, 16)
    bg.Position = UDim2.new(1, -34, 0.5, -8)
    bg.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    bg.BorderSizePixel = 1
    bg.BorderColor3 = Color3.fromRGB(50, 50, 50)
    local box = Instance.new("Frame", bg)
    box.Size = UDim2.new(0, 8, 0, 8)
    box.Position = default and UDim2.new(1, -11, 0.5, -4) or UDim2.new(0, 3, 0.5, -4)
    box.BackgroundColor3 = default and Color3.fromRGB(200, 200, 200) or Color3.fromRGB(60, 60, 60)
    box.BorderSizePixel = 0
    local btn = Instance.new("TextButton", bg)
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.BackgroundTransparency = 1
    btn.Text = ""
    btn.MouseButton1Click:Connect(function()
        default = not default
        box.Position = default and UDim2.new(1, -11, 0.5, -4) or UDim2.new(0, 3, 0.5, -4)
        box.BackgroundColor3 = default and Color3.fromRGB(200, 200, 200) or Color3.fromRGB(60, 60, 60)
        callback(default)
    end)
end

local function createStrictSlider(parent, text, pos, minV, maxV, default, callback)
    local frame = Instance.new("Frame", parent)
    frame.Size = UDim2.new(1, 0, 0, 45)
    frame.Position = pos
    frame.BackgroundTransparency = 1
    local lbl = Instance.new("TextLabel", frame)
    lbl.Size = UDim2.new(1, 0, 0, 15)
    lbl.Text = text:lower()
    lbl.TextColor3 = Color3.fromRGB(130, 130, 130)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 11
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.BackgroundTransparency = 1
    local sBack = Instance.new("Frame", frame)
    sBack.Size = UDim2.new(1, -60, 0, 1)
    sBack.Position = UDim2.new(0, 0, 0, 30)
    sBack.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    sBack.BorderSizePixel = 0
    local sBtn = Instance.new("Frame", sBack)
    sBtn.Size = UDim2.new(0, 2, 0, 10)
    sBtn.Position = UDim2.new((default - minV)/(maxV - minV), -1, 0.5, -5)
    sBtn.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
    sBtn.BorderSizePixel = 0
    local input = Instance.new("TextBox", frame)
    input.Size = UDim2.new(0, 50, 0, 20)
    input.Position = UDim2.new(1, -50, 0, 21)
    input.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
    input.BorderSizePixel = 1
    input.BorderColor3 = Color3.fromRGB(40, 40, 40)
    input.Text = tostring(default)
    input.TextColor3 = Color3.new(1, 1, 1)
    input.Font = Enum.Font.Code
    input.TextSize = 11
    local function update(val)
        val = math.clamp(math.round(val * 100) / 100, minV, maxV)
        input.Text = tostring(val)
        sBtn.Position = UDim2.new((val - minV)/(maxV - minV), -1, 0.5, -5)
        callback(val)
    end
    local dragBtn = Instance.new("TextButton", sBack)
    dragBtn.Size = UDim2.new(1, 20, 1, 30)
    dragBtn.Position = UDim2.new(0, -10, 0, -15)
    dragBtn.BackgroundTransparency = 1
    dragBtn.Text = ""
    local dragging = false
    dragBtn.MouseButton1Down:Connect(function() dragging = true end)
    UserInputService.InputEnded:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end end)
    UserInputService.InputChanged:Connect(function(i)
        if dragging and i.UserInputType == Enum.UserInputType.MouseMovement then
            local rel = math.clamp((i.Position.X - sBack.AbsolutePosition.X) / sBack.AbsoluteSize.X, 0, 1)
            update(minV + (maxV - minV) * rel)
        end
    end)
    input.FocusLost:Connect(function() update(tonumber(input.Text) or default) end)
end

_G.statusRage.MouseButton1Click:Connect(function() isAutoSolving = not isAutoSolving; isWaitingForRound = false; updatePhysics(); refreshStatusUI() end)
_G.statusLegit.MouseButton1Click:Connect(function() isLegitActive = not isLegitActive; refreshStatusUI() end)

createStrictToggle(rageFrame, "freeze", UDim2.new(0,0,0,45), freezeEnabled, function(v) freezeEnabled = v; updatePhysics() end)
createStrictToggle(rageFrame, "auto guess", UDim2.new(0,0,0,75), autoGuess, function(v) autoGuess = v end)
createStrictSlider(rageFrame, "action delay", UDim2.new(0,0,0,110), 0.04, 2, actionDelay, function(v) actionDelay = v end)
createStrictSlider(rageFrame, "spawn delay", UDim2.new(0,0,0,160), 0, 60, startDelayTime, function(v) startDelayTime = v end)

createStrictToggle(legitFrame, "auto flag", UDim2.new(0,0,0,45), autoFlagEnabled, function(v) autoFlagEnabled = v end)
createStrictSlider(legitFrame, "flag range", UDim2.new(0,0,0,80), 5, 200, flagRange, function(v) flagRange = v end)
createStrictSlider(legitFrame, "calculate delay", UDim2.new(0,0,0,130), 0.05, 5, calculateDelay, function(v) calculateDelay = v end)

createStrictToggle(eventFrame, "collect presents", UDim2.new(0,0,0,10), collectPresentsEnabled, function(v) collectPresentsEnabled = v end)

rageTabBtn.MouseButton1Click:Connect(function()
    currentTab = "rage"
    rageFrame.Visible, legitFrame.Visible, eventFrame.Visible = true, false, false
    rageTabBtn.BackgroundColor3, legitTabBtn.BackgroundColor3, eventTabBtn.BackgroundColor3 = Color3.fromRGB(20, 20, 20), Color3.fromRGB(0, 0, 0), Color3.fromRGB(0, 0, 0)
    updatePhysics(); refreshStatusUI()
end)

legitTabBtn.MouseButton1Click:Connect(function()
    currentTab = "legit"
    rageFrame.Visible, legitFrame.Visible, eventFrame.Visible = false, true, false
    legitTabBtn.BackgroundColor3, rageTabBtn.BackgroundColor3, eventTabBtn.BackgroundColor3 = Color3.fromRGB(20, 20, 20), Color3.fromRGB(0, 0, 0), Color3.fromRGB(0, 0, 0)
    updatePhysics(); refreshStatusUI()
end)

eventTabBtn.MouseButton1Click:Connect(function()
    currentTab = "event"
    rageFrame.Visible, legitFrame.Visible, eventFrame.Visible = false, false, true
    eventTabBtn.BackgroundColor3, rageTabBtn.BackgroundColor3, legitTabBtn.BackgroundColor3 = Color3.fromRGB(20, 20, 20), Color3.fromRGB(0, 0, 0), Color3.fromRGB(0, 0, 0)
    updatePhysics(); refreshStatusUI()
end)

player.CharacterAdded:Connect(function()
    if isAutoSolving or isLegitActive then
        isWaitingForRound = true; waitTimeLeft = startDelayTime
        task.spawn(function()
            while waitTimeLeft > 0 do 
                refreshStatusUI()
                task.wait(0.1)
                waitTimeLeft = waitTimeLeft - 0.1 
            end
            isWaitingForRound = false; neighborCache = {}; updatePhysics(); refreshStatusUI()
        end)
    end
end)

refreshStatusUI()
task.spawn(function() while true do pcall(mainLoop) task.wait(0.01) end end)
chatNotify("loaded.")
